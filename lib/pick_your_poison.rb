require 'sinatra'
require 'sinatra-initializers'
require 'geocoder'
require 'httparty'

module PickYourPoison
    class Application < Sinatra::Base
        register Sinatra::Initializers

            get '/' do
                # Grab user's info from twitter link, pass it to index view
                @user_info = params
                puts @user_info
                @current_time = Time.now.strftime('%m/%d/%Y')
                haml :index
            end

            get '/thanks' do
                haml :thanks
            end

            post '/thanks' do
                # Strip out address from Google Places API'd restaurant name
                # params[:restaurant_name] = params[:restaurant_name].gsub /\?,(.*)/, ''
                # puts params[:restaurant_name]
                
                # Convert mm/dd/yyyy date strings generated by datepicker widget to Open311-compliant ISO 8601 date/time strings
                params["problem_date"] = Time.strptime(params[:problem_date], '%m/%d/%Y').iso8601

                # Geocode address from post request, add it to params hash
                full_address = params[:restaurant_address] + ' , Chicago, IL'
                lat, long = Geocoder.coordinates(full_address) 
                puts lat, long
                params[:lat] = lat
                params[:long] = long
                
                puts 'Open311 API Post Service Request:', params

                # Submit form results to open311 test API, print resulting API response to confirm
                response = HTTParty.post('http://test311api.cityofchicago.org/open311/v2/requests.json', :body => { 
                        :api_key => '229b10330f7ec919ce64d349d88fea2e', 
                        :service_code => '4fd6e4ece750840569000019', 
                        :attributePLEASESE => 'FOODPOIS', 
                        :attributeWHATISTH => params[:restaurant_name], 
                        :address_string => params[:restaurant_address],
                        :description => params[:problem_description],
                        :attributeONWHATDA => params[:problem_date],
                        :lat => params[:lat], 
                        :long => params[:long], 
                        :first_name => params[:person_name],
                        :last_name => params[:person_name],
                        :email => params[:person_email]
                    })

                puts 'Open311 API response:', response

                # Add service request token to params hash / mongo document.
                params[:token] = response[0]['token']

 #                # Use token to fetch service_request_id from Open311 API
 #                url = 'http://test311api.cityofchicago.org/open311/v2/tokens/' + params[:token] + '.json'
 #                service_request_id = HTTParty.get(url)[0]['service_request_id']
 #                params[:service_request_id] = service_request_id
 #
 #                puts 'Service Request id:', service_request_id

                # Print fully-assembled document before dumping to reports mongo collection
                puts 'Report hash, pre-mongo insert:', params

                id = REPORTS.insert(params)

                # Confirm document insertion
                puts 'Mongo document, post-insert:', REPORTS.find( '_id' => id ).to_a

                haml :thanks
            end

            get '/about' do
                haml :about
            end

            get '/tweets' do
                # Show recent food poisoning tweets dumped into tweets mongo collection by listener
                @tweets = TWEETS.find.sort( :jDate => :desc ).limit(60)
                haml :tweets
            end

            get '/replies' do
                # Show recent Dan responses to confirmed food poisoning tweets
                @dan_outreach_tweets = DAN_TWEETS.find({:text => /improve/}).limit(30)
                haml :replies

#                dan_confirm_tweets = DAN_TWEETS.find({ :text => /SR#/ }, {:text => true, :in_reply_to_screen_name => true, :jDate => true}).limit(30)
#
#                @convo_list = []
#                for outreach_tweet in dan_outreach_tweets:
#                    convo = []
#
#                    in_reply_screen_name = outreach_tweet['in_reply_to_screen_name']
#                    dan_confirm_tweets[reply_screen_name]
#
#                    for confirm_tweet in dan_confirm_tweets:
#                        if confirm_tweet['in_reply_to_screen_name'] == in_reply_to_screen_name
#                            confirm tweet....
#
#                    end
#                    end
#
#                    convo[0] = outreach_tweet
#                    convo[1] = confirm_tweet
#                    @convo_list += convo
#                end
            end

            get '/reports' do
                # Show recent info for recent form submissions / API service requests
                @reports = REPORTS.find.limit(30)
                haml :reports
            end

    end
end

